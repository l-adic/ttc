// Copyright 2024 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(unused_doc_comments)]
#![no_main]

use alloy_primitives::{Address, B256};
use alloy_sol_types::{SolValue, sol};
use risc0_steel::{
    ethereum::{EthEvmInput, ETH_SEPOLIA_CHAIN_SPEC},
    Contract,
};
use risc0_zkvm::guest::env;
use hashbrown::HashMap;
use ttc::strict::{self, Preferences};

risc0_zkvm::guest::entry!(main);

sol!(
    #[sol(all_derives)]
    TopTradingCycle,
    "../../contract/out/ITopTradingCycle.sol/ITopTradingCycle.json"
);



fn build_owner_dict(prefs: &[ITopTradingCycle::TokenPreferences]) -> HashMap<B256, Address> {
    prefs
        .iter()
        .cloned()
        .map(|tp| (tp.tokenHash, tp.owner))
        .collect()
}

// This function calls the solver and produces the data we need to
// submit to the contract
fn reallocate(
    depositor_address_from_token_hash: &HashMap<B256, Address>,
    prefs: Vec<ITopTradingCycle::TokenPreferences>,
) -> Vec<ITopTradingCycle::TokenReallocation> {
    let prefs = {
        let ps = prefs
            .into_iter()
            .map(
                |ITopTradingCycle::TokenPreferences {
                     tokenHash,
                     preferences,
                     ..
                 }| { (tokenHash, preferences) },
            )
            .collect();
        Preferences::new(ps).unwrap()
    };
    let mut g = strict::PreferenceGraph::new(prefs).unwrap();
    let alloc = strict::Allocation::from(g.solve_preferences().unwrap());
    alloc
        .allocation
        .into_iter()
        .map(|(new_owner, token_hash)| {
            let new_owner = depositor_address_from_token_hash
                .get(&new_owner)
                .unwrap()
                .clone();
            ITopTradingCycle::TokenReallocation {
                newOwner: new_owner,
                tokenHash: token_hash,
            }
        })
        .collect()
}

// Hold on to your butts! This definition better match the one in the contract, but for
// uninteresting reasons (due to Commitment type) we can't use the contract directly.
use risc0_steel::Commitment;
sol! {
    struct Journal {
        Commitment commitment;
        address ttcContract;
        ITopTradingCycle.TokenReallocation[] reallocations;
    }
}


fn main() {
    // Read the input from the guest environment.
    eprintln!("Reading input");
    let input: EthEvmInput = env::read();
    let ttc: Address = env::read();

    // Converts the input into a `EvmEnv` for execution. The `with_chain_spec` method is used
    // to specify the chain configuration. It checks that the state matches the state root in the
    // header provided in the input.
    let env = input.into_env().with_chain_spec(&ETH_SEPOLIA_CHAIN_SPEC);

    // Execute the view call; it returns the result in the type generated by the `sol!` macro.
    let call = TopTradingCycle::getAllTokenPreferencesCall{};
    let preferences = Contract::new(ttc, &env).call_builder(&call).call()._0;
    let initial_owners = build_owner_dict(&preferences);
    let reallocations = {
        let res : Vec<ITopTradingCycle::TokenReallocation> = reallocate(&initial_owners, preferences);
        res.into_iter().filter(|ITopTradingCycle::TokenReallocation { newOwner, tokenHash }| {
            newOwner != initial_owners.get(tokenHash).unwrap()
        }).collect()
    };

    // Commit the block hash and number used when deriving `view_call_env` to the journal.
    let journal = Journal {
        commitment: env.into_commitment(),
        ttcContract: ttc,
        reallocations,
    };

    eprintln!("Committing the result");
    env::commit_slice(&journal.abi_encode());
}